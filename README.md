<!--
  This file was generated by emdaer

  Its template can be found at .emdaer/README.emdaer.md
-->

<!--
  emdaerHash:beba4ded0d24dfff5fd586aa51918d94
-->

<h1 id="middytohof-travis-documented-with-emdaer">middytohof Â· <a href="https://travis-ci.org/chasingmaxwell/middytohof"><img src="https://img.shields.io/travis/chasingmaxwell/middytohof.svg?branch=master?style=plastic" alt="Travis"></a> <a href="https://github.com/emdaer/emdaer"><img src="https://img.shields.io/badge/ðŸ““-documented%20with%20emdaer-F06632.svg?style=flat-square" alt="Documented with emdaer"></a></h1>
<p>Convert <a href="https://github.com/middyjs/middy">Middy</a> middleware plugins to higher-order functions returning lambda handlers.</p>
<h2 id="why-">Why?</h2>
<p>Middy facilitates a middleware pattern very similar to express but for lambda handlers. It encapsulates common functionality into individual plugins separate from the primary business logic of your lambdaâ€™s handler.</p>
<p>Middytohof is for those who want to benefit from the plugins written for the Middy community, but prefer a functional approach over the middleware pattern when it comes to decorating lambda handlers.</p>
<p>Hereâ€™s a quick comparison to give you an idea of the difference:</p>
<h3 id="middleware-pattern-with-middy">Middleware pattern with Middy</h3>

```JavaScript
const { middleware1, middleware2 } = require('middy/middlewares');
const middy = require('middy');

// This contains your primary business logic.
const myHandler = (event, context, callback) => {
  callback(null, { iAm: 'a response' });
};

module.exports = {
  myHandler: middy(myHandler)
    .use(middleware1())
    .use(middleware2()),
};
```
<h3 id="functional-pattern-with-middy-plugins-through-middytohof">Functional pattern with Middy plugins through middytohof</h3>

```JavaScript
const { compose } = require('ramda');
const { middleware1, middleware2 } = require('middy/middlewares');
const middytohof = require('middytohof');

// This contains your primary business logic.
const myHandler = (event, context, callback) => {
  callback(null, { iAm: 'a response' });
};

module.exports = {
  // Without ramda.
  myHandler: middytohof(middleware1())(
    middytohof(middleware2())(
      myHandler
    )
  ),
  // With ramda.
  myHandlerWithRamda: compose(
    middytohof(middleware1()),
    middytoHof(middleware2())
  )(myHandler),
};
```
<p>Either pattern is perfectly reasonable. Now you have the option to choose while keeping the excellent plugins created for the Middy community! :tada:</p>
<h2 id="installation">Installation</h2>
<p><code>yarn add middytohof</code></p>
<p> OR</p>
<p><code>npm i --save middytohof</code></p>
<h2 id="contributors">Contributors</h2>
<details>
<summary><strong>Contributors</strong></summary><br>
<a title="Senior Engineer at @fourkitchens." href="https://github.com/chasingmaxwell">
  <img align="left" src="https://avatars0.githubusercontent.com/u/3128659?s=24">
</a>
<strong>Peter Sieg</strong>
<br><br>
</details>

<h2 id="license">License</h2>
<p>middytohof is <a href="./LICENSE">MIT licensed</a>.</p>
